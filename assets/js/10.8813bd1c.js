(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{259:function(t,e,s){"use strict";s.r(e);var a=s(6),r=Object(a.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h3",{attrs:{id:"逐帧动画和补间动画"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#逐帧动画和补间动画"}},[t._v("#")]),t._v(" 逐帧动画和补间动画")]),t._v(" "),s("h4",{attrs:{id:"来源"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#来源"}},[t._v("#")]),t._v(" 来源")]),t._v(" "),s("p",[t._v("animation默认是以ease的方式进行平滑的过渡，会在每个关键帧之间插入补间动画（ease/linear/贝塞尔曲线等过渡函数都会为其插入补间动画），所以动画效果是连贯性的。")]),t._v(" "),s("p",[t._v("但有些效果不需要补间，只需要关键帧之间的跳跃，这时候就应该使用steps函数的过渡方式。")]),t._v(" "),s("hr"),t._v(" "),s("h4",{attrs:{id:"场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#场景"}},[t._v("#")]),t._v(" 场景")]),t._v(" "),s("p",[t._v("css逐帧动画是通过不断变换keyframes中每个阶段的背景来实现的。比如在0%和100%分别应用不同的背景颜色，就实现了一个最简单的画面切换。")]),t._v(" "),s("p",[t._v("假设我们现在要实现一个行走的小熊，一般做法是先将动画的不同帧做成一张雪碧图，然后不断地变换background-position来达到变换的效果。但是直接使用会有这样的问题：css默认的动画方式是平滑的，平滑的过渡会对过渡动画造成类似滑动的效果，而我们想实现一步一步行走的小熊，就需要使用steps函数来实现。")]),t._v(" "),s("p",[t._v("简单的说，原本一个状态到另一个状态的过渡是平滑的，steps可以实现分步过渡")]),t._v(" "),s("hr"),t._v(" "),s("h4",{attrs:{id:"语法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#语法"}},[t._v("#")]),t._v(" 语法")]),t._v(" "),s("ol",[s("li",[s("p",[s("code",[t._v("steps(n,[start|end])")]),t._v("，n是一个正整数，表示把动画分成n等份。第二个参数表示动画怎么样执行")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("step-start")]),t._v(": 等同于"),s("code",[t._v("steps(1,start)")]),t._v("，会忽略第一帧直接从第二帧开始执行动画")]),t._v(" "),s("li",[s("code",[t._v("step-end")]),t._v(": 等同于"),s("code",[t._v("steps(1,end)")]),t._v("，从第一帧开始执行动画，会忽略最后一帧")])])]),t._v(" "),s("li",[s("p",[t._v("一般动画分成几步完成n就是几，不是keyframes写的变化的次数")])])]),t._v(" "),s("hr"),t._v(" "),s("h4",{attrs:{id:"总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),s("ol",[s("li",[t._v("该属性用于控制动画关键帧的过渡方式，常规的过渡都是平滑的，浏览器会自动为关键帧的间隔中插入补间动画以便视觉上不会出现闪烁。")]),t._v(" "),s("li",[t._v("当我们需要实现“跳跃”的动画时，就需要使用steps函数，将动画分为n个阶段，每个阶段之间的过渡是“跳跃”式的")])]),t._v(" "),s("hr"),t._v(" "),s("h4",{attrs:{id:"示例"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#示例"}},[t._v("#")]),t._v(" 示例")]),t._v(" "),s("iframe",{attrs:{width:"90%",height:"550",allowfullscreen:"allowfullscreen",src:"https://codepen.io/superwtt/embed/OJMYeqe?height=450&theme-id=default&default-tab=result"}}),t._v(" "),s("hr"),t._v(" "),s("h4",{attrs:{id:"参考链接"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参考链接"}},[t._v("#")]),t._v(" 参考链接")]),t._v(" "),s("p",[s("a",{attrs:{href:"http://wanlimm.com/77201809146901.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("steps的使用-hao"),s("OutboundLink")],1)]),t._v(" "),s("p",[s("a",{attrs:{href:"https://www.iteye.com/blog/570109268-2421795",target:"_blank",rel:"noopener noreferrer"}},[t._v("steps的理解"),s("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=r.exports}}]);